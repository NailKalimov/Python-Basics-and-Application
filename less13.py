"""Сортировка, хотя и является базовой операцией, — одна из важнейших операций, которые должен выполнять
компьютер. Она является основой многих других алгоритмов и процедур, таких как поиск и слияние. Знание
различных алгоритмов сортировки поможет вам лучше понять идеи, лежащие в основе разных алгоритмов, а также
разработать более эффективные алгоритмы.

Алгоритм сортировки выбором сортирует массив, находя минимальное значение в несортированной части и затем
заменяя его первым несортированным элементом. Это алгоритм на месте, то есть вам не нужно выделять
дополнительные списки. Несмотря на медленную работу, он по-прежнему используется в качестве основного
алгоритма сортировки в системах с ограниченным объёмом памяти."""


"""Пузырьковая Сортировка
Этот простой алгоритм сортировки перебирает список, сравнивая элементы попарно и меняя их местами до тех пор,
пока более крупные элементы не «всплывут» в конец списка, а более мелкие не останутся «внизу».

Как работает пузырьковая сортировка?
Мы начинаем со сравнения первых двух элементов списка. Если первый элемент больше второго, мы меняем их местами.
Если они уже расположены в правильном порядке, мы оставляем их как есть. Затем мы переходим к следующей паре
элементов, сравниваем их значения и при необходимости меняем местами. Этот процесс продолжается до последней
пары элементов в списке.

Достигнув конца списка, он повторяет этот процесс для каждого элемента. Однако это крайне неэффективно. Что,
если в массиве нужно выполнить только один обмен местами? Зачем нам перебирать его \(n^{2}\) раз, если он уже
отсортирован?

Очевидно, что для оптимизации алгоритма нам нужно останавливать его после завершения сортировки, иначе он
будет многократно перебирать уже отсортированный массив.

Как мы узнаем, что сортировка завершена? Если бы элементы были расставлены по порядку, нам не пришлось бы
ничего менять местами. Поэтому каждый раз, когда мы меняем местами значения, мы устанавливаем флаг True для
повторения процесса сортировки. Если перестановок не было, флаг останется False и алгоритм остановится."""


def bubble_sort(nums):
    # We set swapped to True so the loop looks runs at least once
    swapped = True
    while swapped:
        swapped = False
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                # Swap the elements
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                # Set the flag to True so we'll loop again
                swapped = True

# Verify it works
random_list_of_nums = [5, 2, 1, 8, 4]
bubble_sort(random_list_of_nums)
print(random_list_of_nums)

# Output: [1, 2, 4, 5, 8]
"""
Временная сложность сортировки пузырьком
В худшем случае (когда список расположен в обратном порядке) этому алгоритму придётся поменять местами каждый 
элемент массива. Наш флаг swapped будет устанавливаться в True на каждой итерации.

Таким образом, если в нашем списке n элементов, то на каждый элемент потребуется n итераций. Следовательно, 
временная сложность сортировки пузырьком составляет \(O(n^2)\).
"""


"""
Идея, лежащая в основе сортировки по выбору
Итак, как работает сортировка выбором? При сортировке выбором входной список разбивается на две части: 
отсортированную часть, которая изначально пуста, и несортированную часть, которая изначально содержит список 
всех элементов. Затем алгоритм выбирает минимальное значение из всех несортированных элементов и меняет его 
местами с первым несортированным значением, а затем увеличивает отсортированную часть на единицу.

Давайте посмотрим, как это работает со списком, содержащим следующие элементы: [3, 5, 1, 2, 4].

Мы начинаем с несортированного списка:
3 5 1 2 4
В несортированном разделе есть все элементы. Мы просматриваем каждый элемент и определяем, что 1 является 
наименьшим элементом. Поэтому мы меняем 1 местами с 3:
1 5 3 2 4
Из оставшихся несортированных элементов [5, 3, 2, 4] 2 является наименьшим числом. Теперь мы меняем 2 местами с 5:
1 2 3 5 4
Этот процесс продолжается до тех пор, пока список не будет отсортирован:
1 2 3 5 4
1 2 3 4 5
1 2 3 4 5
"""

def selection_sort(L):
    for i in range(len(L)-1):
        min_index = i
        for j in range(i+1, len(L)-1):
            if L[j] < L[min_index]:
                min_index = j
        L[i], L[min_index] = L[min_index], L[i]

L = [3, 1, 41, 59, 26, 53, 59]
print(L)
selection_sort(L)

print(L)
"""
Расчет временной сложности
https://stackabuse.com/selection-sort-in-python/
"""


"""
СОРТИРОВКА ВСТАВКАМИ
Первый элемент в несортированном массиве оценивается, чтобы мы могли вставить его на нужное место в отсортированном 
подмассиве. Вставка выполняется путём перемещения всех элементов, которые больше нового элемента, на одну позицию 
вправо. Продолжайте делать это до тех пор, пока весь массив не будет отсортирован, вот и всё.


Примечание: имейте в виду, что когда мы говорим, что один элемент больше или меньше другого, это не обязательно 
означает, что он больше или меньше на целое число.

Мы можем использовать слова «больше» и «меньше» по своему усмотрению при работе с пользовательскими объектами. 
Например, точка A может быть «больше», чем точка B, если она находится дальше от центра системы координат.

Мы выделим отсортированный подмассив жирным шрифтом и используем следующий массив для иллюстрации алгоритма:

8, 5, 4, 10, 9
Первым шагом будет «добавить» 8 в наш отсортированный подмассив.

8, 5, 4, 10, 9
Теперь посмотрим на первый несортированный элемент — 5. Мы сохраняем это значение в отдельной переменной, 
например current, на всякий случай. 5 меньше, чем 8. Мы перемещаем 8 на одно место вправо, фактически 
перезаписывая 5, которое было там сохранено ранее (отсюда и отдельная переменная на всякий случай):

8, 8, 4, 10, 9 (current = 5)
5 меньше всех элементов в нашем отсортированном подмассиве, поэтому мы вставляем его на первое место:

5, 8, 4, 10, 9
Далее мы смотрим на число 4. Мы сохраняем это значение в current. 4 меньше 8, поэтому мы сдвигаем 8 вправо 
и делаем то же самое с 5.

5, 5, 8, 10, 9 (current = 4)
И снова мы столкнулись с элементом, который меньше всего нашего отсортированного подмассива, поэтому мы 
помещаем его на первое место:

4, 5, 8, 10, 9
10 больше, чем самый правый элемент в отсортированном подмассиве, и, следовательно, больше, чем любой из 
элементов слева от 8. Поэтому мы просто переходим к следующему элементу:

4, 5, 8, 10, 9
9 меньше 10, поэтому мы сдвигаем 10 вправо:

4, 5, 8, 10, 10 (current = 9)
Однако 9 больше, чем 8, поэтому мы просто вставляем 9 сразу после 8.
 
4, 5, 8, 9, 10
Как реализовать пузырьковую сортировку в Python
Как мы уже упоминали ранее, сортировку вставками довольно легко реализовать. Сначала мы реализуем её 
на простом массиве целых чисел, а затем на некоторых пользовательских объектах.

На практике гораздо более вероятно, что вы будете работать с объектами и сортировать их по определённым критериям.
"""
def insertion_sort(array):

    # We start from 1 since the first element is trivially sorted
    for index in range(1, len(array)):
        currentValue = array[index]
        currentPosition = index

        while currentPosition > 0 and array[currentPosition - 1] > currentValue:
            array[currentPosition] = array[currentPosition -1]
            currentPosition = currentPosition - 1

        array[currentPosition] = currentValue
array = [4, 22, 41, 40, 27, 30, 36, 16, 42, 37, 14, 39, 3, 6, 34, 9, 21, 2, 29, 47]
insertion_sort(array)
print("sorted array: " + str(array))
"""
Сортировка вставок на практике
Сортировка вставками может показаться медленным алгоритмом, и действительно, в большинстве случаев она 
слишком медленная для практического применения из-за своей временной сложности O(n2). Однако, как мы уже 
упоминали, она очень эффективна для небольших массивов и почти отсортированных массивов.
"""


"""
АЛГОРИТМ РАЗДЕЛЯЙ И ВЛАСТВУЙ
"""
# Алгоритм угадывает число от 1 до 1024 за 10 попыток. Пользователь отвечает: загаданное число > или < ответа.
def binary_search():
    arr_len = 1024
    mid = arr_len / 2
    for i in range(1, 11):
        answer = input(f'{round(mid)} \n')
        if answer == '>':
            mid -= (arr_len / 2 ** (i + 1))
        elif answer == '<':
            mid += (arr_len / 2 ** (i + 1))
        elif answer == 'Угадал!':
            print(f'Потребовалось {i} Попыток!')



"""
СОРТИРОВКА СЛИЯНИЕМ
https://i.postimg.cc/vyjMQbd7/marge-sort-in-python-01.png
Этот алгоритм «разделяй и властвуй» делит список пополам и продолжает делить его на две части до тех пор, 
пока в нём не останутся только отдельные элементы.

Соседние элементы становятся отсортированными парами, затем отсортированные пары объединяются и сортируются 
вместе с другими парами. Этот процесс продолжается до тех пор, пока мы не получим отсортированный список со 
всеми элементами несортированного входного списка.

Как работает сортировка слиянием?
Мы рекурсивно делим список пополам до тех пор, пока не получим списки размером в один элемент. Затем мы 
объединяем каждую разделённую половину, сортируя их в процессе.

Сортировка выполняется путём сравнения наименьших элементов каждой половины. Первый элемент каждого списка 
сравнивается первым. Если первая половина начинается с меньшего значения, то мы добавляем его в 
отсортированный список. Затем мы сравниваем второе наименьшее значение первой половины с первым наименьшим 
значением второй половины.

Каждый раз, когда мы выбираем меньшее значение в начале половины, мы на единицу увеличиваем индекс 
элемента, который нужно сравнить.
"""
def merge(left_list, right_list):
    sorted_list = []
    left_list_index = right_list_index = 0
    left_list_length, right_list_length = len(left_list), len(right_list)

    for _ in range(left_list_length + right_list_length):
        if left_list_index < left_list_length and right_list_index < right_list_length:
            if left_list[left_list_index] <= right_list[right_list_index]:
                sorted_list.append(left_list[left_list_index])
                left_list_index += 1
            else:
                sorted_list.append(right_list[right_list_index])
                right_list_index += 1

        elif left_list_index == left_list_length:
            sorted_list.append(right_list[right_list_index])
            right_list_index += 1
        elif right_list_index == right_list_length:
            sorted_list.append(left_list[left_list_index])
            left_list_index += 1

    return sorted_list


def merge_sort(nums):

    if len(nums) == 1:
        return nums

    mid = len(nums) // 2
    left_list = merge_sort(nums[:mid])
    right_list = merge_sort(nums[mid:])

    return merge(left_list, right_list)


random_list_of_nums = [120, 45, 68, 250, 176]
random_list_of_nums = merge_sort(random_list_of_nums)
print(random_list_of_nums)
"""O(n*log(n))"""